{"name":"Famo.us-practice","tagline":"Notes and exercises while going through the 'famous university' http://famo.us/university","body":"Getting started with famo.us/angular\r\n\r\n## First, without Angular\r\n\r\n### Basics\r\n\r\nThe Surface is the most basic renderable - it is equivalent to a\r\ndiv.\r\n\r\n```javascript\r\nvar Engine = require('famous/core/Engine');\r\nvar Surface = require('famous/core/Surface');\r\n\r\nvar mainContext = Engine.createContext();\r\n\r\nvar firstSurface = new Surface({\r\n  content: \"hello world\"\r\n});\r\n\r\nmainContext.add(firstSurface);\r\n```\r\n\r\nYou can modify the content later\r\n\r\n```javascript\r\nfirstSurface.setContent('<h1>HELLO WORLD</h1>');\r\n```\r\n\r\nYou can style it in the same way as css\r\n\r\n```javascript\r\nvar firstSurface = new Surface({\r\n  content: 'hello world',\r\n  properties: {\r\n    color: 'white',\r\n    textAlign: 'center',\r\n    backgroundColor: '#FA5C4F'\r\n  }\r\n});\r\n```\r\n\r\nIf size isn't specified, it inherits the size of the parent.\r\n\r\nYou can be explicit about size by setting the `size` of a surface:\r\n\r\n```javascript\r\n// Specify size in pixels with [x, y]\r\n// Specify size in only one dimension with [undefined, y] or [x, undefined]\r\n// Have the surface auto-size according to the content with [true, true]\r\n\r\nvar firstSurface = new Surface({\r\n  size: [true, true],\r\n  content: 'hello world',\r\n  properties: {\r\n    color: 'white',\r\n    textAlign: 'center',\r\n    backgroundColor: '#FA5C4F'\r\n  }\r\n});\r\n```\r\n\r\nA surface that displays your name, is 200px wide and 100% in height, has\r\n#FA5C4F background color, has white, center aligned text, has 40px font size,\r\nhas 15px border radius\r\n\r\n```javascript\r\nvar Engine = require('famous/core/Engine');\r\nvar Surface = require('famous/core/Surface');\r\nvar mainContext = Engine.createContext();\r\n\r\nvar surface = new Surface({\r\n  content: '<h4>Brent Vatne</h1>',\r\n  size: [200, undefined],\r\n  properties: {\r\n    textAlign: 'center',\r\n    background: '#FA5C4F',\r\n    color: '#fff',\r\n    fontSize: '40px',\r\n    borderRadius: '15px'\r\n  }\r\n})\r\n\r\nmainContext.add(surface);\r\n```\r\n\r\nYou can position a surface using a modifier\r\n\r\n```javascript\r\nvar stateModifier = new StateModifier({\r\n  transform: Transform.translate(150, 100, 0)\r\n});\r\n\r\nmainContext.add(stateModifier).add(surface);\r\n```\r\n\r\nYou can chain modifiers, but the order of the chaining matters! eg: if\r\nyou rotate and then translate, it is different than translate and then\r\nrotate.\r\n\r\n```javascript\r\nmainContext\r\n  .add(translateModifierOne)\r\n  .add(rotateModifierOne)\r\n  .add(redSurface);\r\n```\r\n\r\nYou can branch modifiers by saving a reference to the context with the\r\nmodifier applied:\r\n\r\n```javascript\r\nvar node = mainContext.add(downMod);\r\nnode.add(leftSurface);\r\nnode.add(rightMod).add(rightSurface);\r\n```\r\n\r\nYou can change the origin, align, opacity, scale, etc.\r\n\r\n```javascript\r\nvar originModifier = new StateModifier({\r\n  opacity: 0.8,\r\n  transform: Transform.scale(4, 3, 0.5),\r\n  align: [0.5, 0.5],\r\n  origin: [0.5, 0.5]\r\n});\r\n```\r\n\r\nNot clear still on difference between origin and align.. origin for\r\nchild, align for parent..\r\n\r\n### Animations\r\n\r\nAnimations can be done by using setTransform on a stateModifier:\r\n\r\n```javascript\r\nvar stateModifier = new StateModifier();\r\n\r\nmainContext.add(stateModifier).add(surface);\r\n\r\nstateModifier.setTransform(\r\n  Transform.translate(100, 300, 0),\r\n  { duration : 1000, curve: 'easeInOut' }\r\n);\r\n\r\n// This one runs after the previous animation is complete\r\nstateModifier.setTransform(\r\n  Transform.translate(150, 10, 0),\r\n  { duration : 1000, curve: 'easeInOut' },\r\n  function() {\r\n    alert('Done animations!')\r\n  }\r\n);\r\n```\r\n\r\nLots of easings to use - access these ones with Easing.easeName in the\r\ncurve option - rather than the string value above 'easeInOut'\r\n\r\ninQuad outQuad inOutQuad inCubic outCubic inOutCubic inQuart outQuart inOutQuart inQuint outQuint inOutQuint inSine outSine inOutSine inExpo outExpo inOutExpo inCirc outCirc inOutCirc inElastic outElastic inOutElastic inBack outBack inOutBack inBounce outBounce inOutBounce\r\n\r\nYou can interrupt animations before they end by calling `halt()` on the\r\nstate modifier. If you don't do another `setTransform` after halting\r\nthen it will just jump right to the finished state of the transform that\r\nwas halted - this will look ugly so it's best to finish it off quickly,\r\nlike below.\r\n\r\n```javascript\r\nstateModifier.setTransform(\r\n  Transform.translate(0, 400, 0),\r\n  { duration : 8000, curve: 'linear' }\r\n);\r\n\r\nsurface.on('click', function() {\r\n  stateModifier.halt();\r\n  surface.setContent('halted');\r\n  stateModifier.setTransform(\r\n    Transform.translate(0, 400, 0),\r\n    { duration : 400, curve: Easing.outBounce }\r\n  );\r\n```\r\n\r\nYou can use physics transitions instead of easing curves\r\n\r\n```javascript\r\nvar SpringTransition = require('famous/transitions/SpringTransition');\r\nTransitionable.registerMethod('spring', SpringTransition);\r\n\r\nstateModifier.setTransform(\r\n  Transform.translate(0, 300, 0),\r\n  { method: 'spring', period: 1000, dampingRatio: 0.3 }\r\n);\r\n```\r\n\r\n### Events\r\n\r\n#### Surface events\r\n\r\nclick mousedown mousemove mouseup mouseover mouseout touchstart touchmove touchend touchcancel keydown keyup keypress\r\n\r\n```javascript\r\nsurface.on('mouseover', function() {\r\n  surface.setProperties({\r\n    backgroundColor: '#878785'\r\n  });\r\n});\r\n\r\nsurface.on('mouseout', function() {\r\n  surface.setProperties({\r\n    backgroundColor: '#FA5C4F'\r\n  });\r\n});\r\n```\r\n\r\n`touch` events don't work with a desktop click.\r\n\r\n#### Engine events\r\n\r\n```javascript\r\nEngine.on('keydown', function(e) {\r\n  surface.setContent(e.which);\r\n});\r\n```\r\n\r\nThis is like doing `$(document).on('click')` - events are first given a\r\nchance to be handled by the surface that they are triggered on, then\r\npropagate up to the Engine.\r\n\r\nIt also has some other useful events that aren't triggered on surfaces,\r\nlike `prerender` and `postrender` and `resize`. The render events are\r\ntriggered approximately every 16.7ms at 60fps.\r\n\r\n```javascript\r\nEngine.on('resize', function() {\r\n  surface.setContent('resized');\r\n});\r\n```\r\n\r\n#### Program events\r\n\r\n\"Events are a way of moving information between program modules in a\r\ndecoupled way. In Famo.us we emit, transmit, and listen to program\r\nevents using Event Handler objects.\" - in other words, you can use this\r\nas an event bus between multiple components for inter-component communication.\r\n\r\n```javascript\r\nvar surface;\r\ncreateSurface();\r\nvar eventHandler = new EventHandler();\r\n\r\nsurface.on('click', function() {\r\n  eventHandler.emit('hello');\r\n});\r\n\r\neventHandler.on('hello', function() {\r\n  surface.setContent('heard hello');\r\n});\r\n```\r\n\r\nNot quite sure why yet, but apparently it's more common to have multiple\r\nevent handlers which subscribe to each other.\r\n\r\n```javascript\r\nvar surfaceA, surfaceB;\r\ncreateSurfaces();\r\n\r\nvar eventHandlerA = new EventHandler();\r\nvar eventHandlerB = new EventHandler();\r\n\r\nsurfaceA.on('click', function() {\r\n  eventHandlerA.emit('hello');\r\n  surfaceA.setContent('said hello');\r\n});\r\n\r\neventHandlerB.subscribe(eventHandlerA);\r\n// eventHandlerA.pipe(eventHandlerB); has the same effect\r\n// but eventHandlerA will emit to B, which is unaware of A,\r\n// whereas in subscribe, eventHandlerA is unaware of B.\r\n\r\neventHandlerB.on('hello', function() {\r\n  surfaceB.setContent('heard hello');\r\n});\r\n```\r\n\r\nUse views to organize code and aggregate events.\r\n```javascript\r\nvar myView = new View();\r\nmainContext.add(myView);\r\n\r\nvar surface = new Surface // etc ..\r\n\r\nmyView.add(surface);\r\nsurface.pipe(myView);\r\n\r\n// normally inside view module's code\r\nmyView._eventInput.on('click', function() {\r\n  myView._eventOutput.emit('hello');\r\n});\r\n\r\n// listening to view's events from the outside\r\nmyView.on('hello', function() {\r\n  surface.setContent('hello');\r\n});\r\n```\r\n\r\nUnlike surfaces, views don't actually map to DOM elements - \"they're\r\nempty render nodes with some extra features.\" In addition, they do not\r\nhave a size by default. So we need to use a StateModifier to set their\r\nsize. The following example defines a `SlideView` class, which inherits\r\nfrom the base `View` class and sets a size on it.\r\n\r\n\r\n```javascript\r\ndefine(function(require, exports, module) {\r\n  var View = require('famous/core/View');\r\n  var Surface = require('famous/core/Surface');\r\n  var Transform = require('famous/core/Transform');\r\n  var StateModifier = require('famous/modifiers/StateModifier');\r\n\r\n  function SlideView() {\r\n    View.apply(this, arguments);\r\n\r\n    this.rootModifier = new StateModifier({\r\n        size: [400, 450]\r\n    });\r\n\r\n    // saving a reference to the new node\r\n    this.mainNode = this.add(this.rootModifier);\r\n  }\r\n\r\n  SlideView.prototype = Object.create(View.prototype);\r\n  SlideView.prototype.constructor = SlideView;\r\n\r\n  SlideView.DEFAULT_OPTIONS = {};\r\n\r\n  module.exports = SlideView;\r\n});\r\n```\r\n\r\nEvents get captured at the surface level and do not automatically bubble up to the view\r\n\r\n```javascript\r\n// Where slide is a view, and we want this to be called whenever any of\r\n// the surfaces within that view are clicked.\r\nslide.on('click', this.showNextSlide.bind(this));\r\n```\r\n\r\nIf there are several surfaces inside of the `slide` view here, we can\r\njust set some of them to have `pointerEvents: 'none'` in the properties\r\nand attach the click handler to whichever surface spans the whole view.\r\n\r\n```javascript\r\n// Where this is the instance of the slide view\r\n// * Be sure to bind the callback to this also, otherwise there\r\n//   will be a stack overflow as it will just repeatedly emit\r\n//   click on the surface.\r\n//\r\nbackground.on('click', function() {\r\n  // the event output handler is used to broadcast outwards\r\n  this._eventOutput.emit('click');\r\n}.bind(this));\r\n\r\n// And for the other surfaces, make them not register click events\r\n// For example on the photo ImageSurface:\r\nvar photo = new ImageSurface({\r\n  size: [size, size],\r\n  content: this.options.photoUrl,\r\n  properties: {\r\n    zIndex: 2,\r\n    pointerEvents: 'none'\r\n  }\r\n});\r\n```\r\n\r\n### Speaking of ImageSurface..\r\nUse this instead of setting content of `<img>` inside of a normal\r\nsurface - `ImageSurface` will only be rendered as an `img` tag, whereas\r\nif it was within a surface it would be nested within a `div`.\r\n\r\n\r\n### Pitfalls\r\n\r\n* It's good to set both z-index and z-translate - some browsers don't\r\n  work properly so both will be required\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}